/**
 * @fileoverview Service functions for creating Zora coins
 * @module createCoin
 */

import {createCoinCall, createCoin} from "@zoralabs/coins-sdk";
import { setApiKey } from "@zoralabs/coins-sdk";
import { base } from 'viem/chains';
import { toast } from 'react-hot-toast';

// Determine the global object based on environment
const globalObj = typeof window !== 'undefined' ? window : 
                  typeof global !== 'undefined' ? global : 
                  typeof self !== 'undefined' ? self : {};

// Patch the fetch to intercept problematic IPFS requests
const originalFetch = globalObj.fetch;

// Create a proxy fetch function that intercepts problematic IPFS URLs
globalObj.fetch = async function patchedFetch(url, options) {
  // Check if this is an IPFS URL from a problematic domain
  const urlStr = url.toString();
  
  // Specifically intercept the problematic gateway that's timing out
  if (urlStr.includes('magic.decentralized-content.com/ipfs/') || 
      urlStr.includes('decentralized-content.com') ||
      (urlStr.includes('/ipfs/QmdQ4a57yA1J3qe1Mi8ThBBimKvEkyywNEts1ERXgv3oFt'))) {
    
    console.log(`ðŸ”„ Intercepting problematic IPFS request: ${urlStr}`);
    
    try {
      // Extract the IPFS hash
      let hash = '';
      if (urlStr.includes('/ipfs/')) {
        hash = urlStr.split('/ipfs/').pop().split('/')[0].split('?')[0];
      }
      
      if (!hash) {
        console.warn('Could not extract IPFS hash from URL, using original fetch');
        return originalFetch(url, options);
      }
      
      // Redirect to our proxy
      const baseUrl = typeof window !== 'undefined' 
        ? window.location.origin 
        : process.env.NEXT_PUBLIC_URL || 'http://localhost:3000';
      
      const proxyUrl = `${baseUrl}/api/ipfs?hash=${hash}`;
      console.log(`ðŸ”€ Redirecting to local IPFS proxy: ${proxyUrl}`);
      
      // Use original fetch with our proxy URL
      return originalFetch(proxyUrl, options);
    } catch (error) {
      console.error('Error in fetch proxy, falling back to original fetch:', error);
      return originalFetch(url, options);
    }
  }
  
  // For all other URLs, use the original fetch
  return originalFetch(url, options);
};

// Initialize API key for production environments
// Uses environment variable or allows manual override
const initializeApiKey = () => {
  const apiKey = process.env.NEXT_PUBLIC_ZORA_API_KEY;
  if (apiKey) {
    setApiKey(apiKey);
    console.log("Zora API key initialized from environment variables");
  }
};

// Call initialization on module load
initializeApiKey();

// SDK'nÄ±n iÅŸaret ettiÄŸi ve starter kit'in muhtemelen kullandÄ±ÄŸÄ± (kanonik olmayan) fabrika adresi
const ZORA_FACTORY_ADDRESS_SDK_TARGET = '0x02B2705500096Ff83F9eF78873ca5DFB06C00Ddc';
// Bu spesifik fabrika adresi iÃ§in Base'de Ã§alÄ±ÅŸan tickLower deÄŸeri
const WETH_TICK_LOWER_FOR_SDK_TARGET = -208200;


/**
 * Prepares contract call parameters for coin creation
 * @param {Object} params - Contract call parameters
 * @param {string} params.name - Name of the coin
 * @param {string} params.symbol - Trading symbol for the coin
 * @param {string} params.uri - Metadata URI (IPFS URI recommended)
 * @param {string} params.payoutRecipient - Address that receives creator earnings
 * @param {string} [params.platformReferrer] - Optional platform referrer address
 * @param {bigint} [params.initialPurchaseWei] - Optional initial purchase amount
 * @returns {Promise<object>} Contract call parameters
 */
export async function getCoinCreationParams({
  name,
  symbol,
  uri,
  payoutRecipient,
  initialPurchaseWei = 0n
}) {
  try {
    if (!name || !symbol || !uri || !payoutRecipient) {
      throw new Error("Required parameters missing");
    }

    // Log the parameters we intend to use
    console.log("Preparing coin creation using SDK's target address:", {
      factoryAddress: ZORA_FACTORY_ADDRESS_SDK_TARGET, // Using the non-canonical address
      name,
      symbol,
      uri,
      payoutRecipient,
      initialPurchaseWei,
      tickLower: WETH_TICK_LOWER_FOR_SDK_TARGET // Using the tickLower required for this address
    });

  

    // Call SDK's createCoinCall, providing the required tickLower
    const sdkParams = await createCoinCall({
      name,
      symbol,
      uri, // Use the provided URI directly, no need to recreate it
      payoutRecipient,
      initialPurchaseWei,
      // Provide the specific tickLower needed for the 0x02B... address
      tickLower: WETH_TICK_LOWER_FOR_SDK_TARGET
    });

    // Log the parameters returned by SDK (address will be overridden)
    console.log("Parameters generated by SDK (address will be overridden):", sdkParams);

    if (!sdkParams?.abi || !sdkParams?.functionName || !sdkParams?.args) {
      throw new Error("SDK failed to generate valid base parameters");
    }

    // *** Override the address with the one we intend to use (SDK's target) ***
    const finalParams = {
        ...sdkParams,
        address: ZORA_FACTORY_ADDRESS_SDK_TARGET, // Ensure we target the 0x02B... address
    };

    // Verify the tickLower in the final args matches our required value
    if (sdkParams.args && sdkParams.args.length > 7 && sdkParams.args[7] !== WETH_TICK_LOWER_FOR_SDK_TARGET) {
        console.warn(`SDK returned tickLower ${sdkParams.args[7]}, but we are forcing ${WETH_TICK_LOWER_FOR_SDK_TARGET}.`);
        finalParams.args = [...sdkParams.args]; // Create a mutable copy
        finalParams.args[7] = WETH_TICK_LOWER_FOR_SDK_TARGET;
    }

    // Return the parameters targeting the SDK's address with the correct tickLower
    console.log("Final parameters for simulation (using SDK target address, required tickLower):", finalParams);
    return finalParams;
  } catch (error) {
    console.error("Error preparing contract parameters:", error);
    throw new Error(`Failed to prepare contract parameters: ${error.message}`);
  }
} 

/**
 * Validates URI and ensures it's a proper IPFS URI
 * @param {string} uri - URI to validate
 * @returns {string} Validated URI
 */
const validateAndFixUri = (uri) => {
  if (!uri) {
    throw new Error("URI is required for coin creation");
  }

  // If URI isn't in ipfs:// format, try to fix it
  if (!uri.startsWith('ipfs://')) {
    // Try to extract IPFS hash from HTTP URL
    if (uri.includes('/ipfs/')) {
      const hash = uri.split('/ipfs/').pop();
      console.log("Extracted IPFS hash from HTTP URL:", hash);
      return `ipfs://${hash}`;
    }
    
    // Handle direct gateway links like gateway.pinata.cloud/{hash}
    const lastSegment = uri.split('/').pop();
    if (lastSegment && lastSegment.length > 20) {
      console.log("Extracted potential IPFS hash from URL:", lastSegment);
      return `ipfs://${lastSegment}`;
    }
    
    console.warn("URI doesn't follow ipfs:// format:", uri);
  }
  
  return uri;
};

/**
 * Creates a Zora coin using the SDK's createCoin function
 * @param {Object} params - Coin creation parameters
 * @param {string} params.name - Name of the coin
 * @param {string} params.symbol - Trading symbol for the coin
 * @param {string} params.uri - Metadata URI (IPFS URI recommended)
 * @param {string} params.payoutRecipient - Address that receives creator earnings
 * @param {Array<string>} [params.owners] - Optional array of owner addresses
 * @param {bigint} [params.initialPurchaseWei] - Optional initial purchase amount
 * @param {Object} walletClient - Viem wallet client
 * @param {Object} publicClient - Viem public client
 * @param {Object} [options] - Additional options
 * @param {number} [options.gasMultiplier] - Gas multiplier percentage
 * @returns {Promise<object>} Transaction result with hash, receipt, and coin address
 */
export async function createZoraCoin({
  name,
  symbol,
  uri,
  payoutRecipient,
  owners = [],
  initialPurchaseWei = 0n
}, walletClient, publicClient, options = {}) {
  try {
    if (!name || !symbol || !uri || !payoutRecipient) {
      throw new Error("Required parameters missing");
    }
    
    if (!walletClient || !publicClient) {
      throw new Error("Wallet client and public client are required");
    }

    // If owners array is empty, use payoutRecipient as the owner
    if (!owners || owners.length === 0) {
      owners = [payoutRecipient];
    }
    
    // Validate and fix the URI if needed
    const validatedUri = validateAndFixUri(uri);

    // Ensure initialPurchaseWei is a valid bigint and is within reasonable bounds
    if (typeof initialPurchaseWei !== 'bigint') {
      console.warn("initialPurchaseWei was not a bigint, converting to bigint");
      try {
        initialPurchaseWei = BigInt(initialPurchaseWei || 0);
      } catch (e) {
        console.error("Failed to convert initialPurchaseWei to bigint:", e);
        initialPurchaseWei = 0n;
      }
    }

    // Log the parameters we intend to use
    console.log("Creating coin with direct SDK call:", {
      name,
      symbol,
      uri: validatedUri,
      payoutRecipient,
      owners,
      initialPurchaseWei: initialPurchaseWei.toString(), // Convert to string for clean logging
      tickLower: WETH_TICK_LOWER_FOR_SDK_TARGET
    });

    // Check for correct chain (Base = 8453)
    const walletChainId = await walletClient.getChainId();
    if (walletChainId !== base.id) {
      // Show clear notification to user about wrong network
      toast.error(`You're connected to network ID ${walletChainId}, but Base network (${base.id}) is required. Please switch networks.`, { 
        id: "network-error", 
        duration: 5000 
      });
      
      throw new Error(`Chain mismatch: Connected to chain ${walletChainId}, but Base (${base.id}) is required. Please switch networks.`);
    }

    // Check user's balance to ensure they have enough for this transaction
    try {
      const [walletAddress] = await walletClient.getAddresses();
      const balance = await publicClient.getBalance({ address: walletAddress });
      
      if (balance < initialPurchaseWei) {
        toast.error("Your wallet doesn't have enough funds for this transaction", {
          id: "balance-error",
          duration: 5000
        });
        throw new Error(`Insufficient funds: wallet has ${balance.toString()} wei, but transaction requires at least ${initialPurchaseWei.toString()} wei`);
      }
    } catch (balanceError) {
      console.warn("Balance check failed, proceeding anyway:", balanceError);
      // Continue with the transaction attempt - the chain will reject if insufficient funds
    }

    // Maximum retries for handling metadata fetch errors
    const MAX_RETRIES = 3;
    let attempt = 0;
    let lastError = null;

    // Function to convert metadata to HTTP URL from IPFS
    const convertToHttpUrl = (ipfsUri) => {
      if (!ipfsUri) return null;
      if (ipfsUri.startsWith('ipfs://')) {
        const hash = ipfsUri.substring(7);
        return `https://gateway.pinata.cloud/ipfs/${hash}`;
      }
      return ipfsUri;
    };

    // Function to create a publicly accessible metadata URL
    const createPublicMetadataUrl = async (name, symbol, description) => {
      try {
        // SDK'nÄ±n kendi sÃ¼recini kullanÄ±yoruz, hazÄ±r veri kullanmaktan kaÃ§Ä±nÄ±yoruz
        console.log("DoÄŸrudan URI kullanmaya Ã§alÄ±ÅŸÄ±yoruz");
        throw new Error("URI eriÅŸilemedi");
      } catch (error) {
        console.error("Metadata URI eriÅŸim hatasÄ±:", error);
        throw error; // Hata durumunu Ã¼st seviyeye ilet
      }
    };

    while (attempt < MAX_RETRIES) {
      try {
        // Use the SDK's createCoin function directly
        const result = await createCoin(
          {
            name,
            symbol,
            uri: validatedUri,
            payoutRecipient,
            owners,
            initialPurchaseWei,
            tickLower: WETH_TICK_LOWER_FOR_SDK_TARGET
          },
          walletClient,
          publicClient,
          { gasMultiplier: options.gasMultiplier || 120 } // Default to 120% gas
        );

        console.log("Coin created successfully:", {
          hash: result.hash,
          address: result.address
        });

        return result;
      } catch (error) {
        attempt++;
        lastError = error;
        
        console.error(`Attempt ${attempt}/${MAX_RETRIES} failed:`, error);
        
        // Check if this is an insufficient funds error
        if (error.message && (
            error.message.includes("insufficient funds") ||
            error.message.includes("exceeds the balance") ||
            error.message.includes("Insufficient funds")
        )) {
          toast.error("Not enough ETH in your wallet to complete this transaction", {
            id: "funds-error",
            duration: 4000
          });
          
          // This is a terminal error - no point in retrying
          throw new Error(`Transaction failed due to insufficient funds: ${error.message}`);
        }
        
        // Check if this is a metadata fetch error
        if (error.message && (
            error.message.includes("Metadata fetch failed") || 
            error.message.includes("metadata") || 
            error.message.includes("URI") ||
            error.message.includes("ipfs")
        )) {
          // Create a public HTTP URL for the metadata
          if (attempt === MAX_RETRIES - 1) {
            try {
              const publicMetadataUrl = await createPublicMetadataUrl(name, symbol, `${name} token`);
              console.log("Using public HTTP metadata URL as fallback:", publicMetadataUrl);
              
              const result = await createCoin(
                {
                  name,
                  symbol,
                  uri: publicMetadataUrl,
                  payoutRecipient,
                  owners,
                  initialPurchaseWei,
                  tickLower: WETH_TICK_LOWER_FOR_SDK_TARGET
                },
                walletClient,
                publicClient,
                { gasMultiplier: options.gasMultiplier || 120 }
              );
              
              console.log("Coin created successfully with public metadata URL:", {
                hash: result.hash,
                address: result.address
              });
              
              return result;
            } catch (httpError) {
              console.error("Public metadata URL fallback also failed:", httpError);
              // Continue to try one more approach
            }
          }
          
          // If all previous attempts fail, try with a hardcoded URI
          if (attempt === MAX_RETRIES) {
            try {
              console.log("Son deneme, doÄŸrudan IPFS URI kullanÄ±lÄ±yor...");
              // SDK'nÄ±n kendi sÃ¼recine daha fazla ÅŸans tanÄ±yoruz
              throw new Error("DoÄŸrudan IPFS URI kullanÄ±mÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±");
            } catch (fallbackError) {
              console.error("TÃ¼m yaklaÅŸÄ±mlar baÅŸarÄ±sÄ±z oldu:", fallbackError);
              throw fallbackError;
            }
          }
          
          // Wait before retrying
          console.log(`Waiting before retry ${attempt}...`);
          await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
          continue;
        } else {
          // If it's not a metadata error, re-throw immediately
          throw error;
        }
      }
    }
    
    // If we've exhausted all retries, throw the last error
    throw lastError || new Error("Failed to create coin after multiple attempts");
  } catch (error) {
    console.error("Error creating coin:", error);
    throw new Error(`Failed to create coin: ${error.message}`);
  }
} 